{"name":"Mox","tagline":"Utility library for AngularJS/Jasmine mocks","body":"# Mox: Mocking utility library for AngularJS apps\r\n\r\n[![Build Status](https://travis-ci.org/fvanwijk/mox.svg?branch=master)](https://travis-ci.org/fvanwijk/mox)\r\n[![Test Coverage](https://codeclimate.com/github/fvanwijk/mox/badges/coverage.svg)](https://codeclimate.com/github/fvanwijk/mox)\r\n[![Code Climate](https://codeclimate.com/github/fvanwijk/mox/badges/gpa.svg)](https://codeclimate.com/github/fvanwijk/mox)\r\n\r\nWhen it comes to unit tests, normally a lot of boilerplate code is written to set up the mocks. This library consists of\r\nsome utility functions to set up mocks very fast and have total control of the scope of your tests.\r\n\r\n## Usage\r\nCopy moxConfig.js to your project test folder. Put mox.js and moxConfig.js in your karma.conf.js file list, is this order:\r\n\r\n```javascript\r\nfiles: [\r\n...\r\n  'bower_components/jasmine-mox-matchers/src/jasmine-mox-matchers.js' // or dist/jasmine-mox-matchers.min.js\r\n  'bower_components/mox/dist/mox.js', // Or mox.min.js\r\n  'test/moxConfig.js',\r\n...\r\n],\r\n```\r\n\r\n## Full usage example\r\n\r\n```javascript\r\ndescribe('Example of Mox', function () {\r\n\r\n  beforeEach(function() {\r\n\r\n    mox\r\n      .module(\r\n        'myApp',\r\n        function ($provide) {\r\n          // Custom module config function\r\n          $provide.constant('yolo', 'swag');\r\n        }\r\n      )\r\n      .mockServices(\r\n        'FooService',\r\n        'barFilter'\r\n      )\r\n      .mockConstants({\r\n        fooConstant: value\r\n      })\r\n      .mockDirectives(\r\n        'bazDirective',\r\n        {\r\n          name: 'yoloDirective',\r\n          template: '<div>Custom directive template</div>',\r\n          link: function customLinkFn() { }\r\n        }\r\n      )\r\n      .disableDirectives(\r\n        'fooDirective'\r\n      )\r\n      .setupResults(function () {\r\n        return {\r\n          fooService: {\r\n            getBars: ['barData1', 'barData2'],\r\n            getTranslation: function (key) {\r\n              return key == 'fooTitle' ? 'mock title' : key;\r\n            }\r\n          },\r\n          barFilter: 'mock filter result' // Object not allowed as return value\r\n        };\r\n      })\r\n      .mockTemplates(\r\n        'scripts/views/template1.html',\r\n        'scripts/views/template2.html',\r\n      )\r\n      .mockControllers('ChildController')\r\n      .run();\r\n\r\n    createScope();\r\n    createController('FooController');\r\n\r\n    it('should do something', function () {\r\n\r\n      var FooService  = mox.inject('FooService');\r\n      expect(this.$scope.foo).toBe('bar');\r\n      expect(FooService).toBe(mox.get.FooService);\r\n      expect(FooService.getBars()).toEqual(['barData1', 'barData2']);\r\n\r\n      var translation = FooService.getTranslation('fooTitle');\r\n\r\n      expect(FooService.getTranslation).toHaveBeenCalledWith('fooTitle');\r\n      expect(translation).toBe('mockTitle');\r\n\r\n    });\r\n\r\n  });\r\n\r\n});\r\n```\r\n\r\n## Mox registration methods\r\n\r\n### mox.inject()\r\n\r\nInject services directly using `inject('<service>')`, for example:\r\n\r\n```javascript\r\nvar fooService = inject('FooService');\r\nfooService.doSomething();\r\nvar services = inject('FooService', 'BarService'); // { FooService: ..., BarService: ... }\r\nservices.FooService.doSomething();\r\n```\r\n\r\nThis can be used instead of using a inject wrapper such as `inject(function(FooService) { })`.\r\nThe `mox.inject` function can also be used to get mocked services but it is prefered to use `mox.get.FooService`.\r\n\r\n\r\n\r\n### mox.module()\r\n\r\nSets up the module, just like [module()](https://docs.angularjs.org/api/ngMock/function/angular.mock.module) does.\r\nPass module names, config functions or objects. The passed arguments are executed when `run()` is called.\r\n\r\nReturns the Mox instance to make chaining possible.\r\n\r\n```javascript\r\nmox.module('foo', function ($provide) {\r\n  $provide.constant('foo', 'bar');\r\n})\r\n```\r\n\r\n### mox.mockServices()\r\n\r\nRegisters services to be mocked. This can be an Angular factory, service and/or filter. The mocked service will be a spy\r\nobject with spies for every method in the original service, unless there is a factory function defined in the moxConfig.js file.\r\nThis function tries create a resource mock or normal mock depending on the mock name prefix (`Filter` or `Resource`).\r\nThe following mocks are created:\r\n\r\n* when mock factory exists in `moxConfig.js`: jasmine spy object with spy methods as defined in mock (factory function is executed)\r\n* when name ends with `Filter`: jasmine spy\r\n* when name ends with `Resource`: jasmine spy object with spy methods `get`, `query`, `save`, `remove`, `delete`,\r\n  `$get`, `$query`, `$save`, `$remove`, `$delete`\r\n* otherwise a jasmine spy object with spy methods from the original service\r\n\r\nOne service:\r\n\r\n```javascript\r\nmox.mockServices('FooResource')\r\n```\r\n\r\nMultiple services:\r\n\r\n```javascript\r\nmox.mockServices(\r\n   'fooResource',\r\n   'barService'\r\n)\r\n```\r\n\r\nReturns the Mox instance to make chaining possible.\r\n\r\n### mox.mockConstants()\r\n\r\nRegister constants to be mocked and define their value. These mocks can be injected in a config function immediately.\r\nPass a name and value as parameters for one constant, or an object with definitions for multiple constants.\r\n\r\nOne constant:\r\n\r\n```javascript\r\nmox.mockConstant('FooConstant', 'value')\r\n```\r\n\r\nMultiple constants:\r\n\r\n```javascript\r\nmox.mockConstant({\r\n  FooConstant: value,\r\n  BarConstant: anotherValue\r\n})\r\n```\r\n\r\n### mox.mockDirectives()\r\n\r\nRegister directive(s) to be mocked. The mock will be an empty directive with the same isolate scope as the original directive,\r\nso the isolate scope of the directive can be tested:\r\n\r\n```javascript\r\ncompiledElement.find('[directive-name]').toContainIsolateScope({ key: value });\r\n```\r\n\r\nAccepts 3 types of input:\r\n1. a directive name: the same as with an array, but just for one directive\r\n2. a directive factory object, for your own mock implementation.\r\n  - name property is required\r\n  - scope, priority and restrict properties are not overwritable\r\n3. an array of directive names (see 1) or objects (see 2)\r\n\r\nReturns the Mox instance to make chaining possible.\r\n\r\n### mox.disableDirectives()\r\n\r\n\"Disables\" the given list of directives, not just mocking them.\r\nAccepts directive name or array with directive names to disable.\r\n\r\nReturns the Mox instance to make chaining possible.\r\n\r\n### mox.mockControllers()\r\n\r\nRegisters controllers to be mocked. This is useful for view specs where the template contains an `ng-controller`.\r\nThe view's `$scope` is not set by the controller anymore, but you have to set the `$scope` manually.\r\n\r\n```javascript\r\nmox.mockControllers('FooController')\r\n```\r\n\r\nReturns the Mox instance to make chaining possible.\r\n\r\n### mox.run()\r\n\r\nExecutes all registered stuff so that the actual mocking is done. If you forget to call `run()`, nothing will be mocked.\r\nThe real services will be overwritten by mocks via `$provide.value`, so when you inject `FooService`, you get the mocked service, including\r\nspies on all methods.\r\n\r\nAs bonus, the mocks are added to the `mox.get` object, so that you can access mocks easily in your specs without having to inject them.\r\n\r\nReturns the result of angular.mocks.module`, so that the call can passed as argument to `beforeEach`. So chaining is not possible after `run()`.\r\n\r\n```javascript\r\nbeforeEach(function () {\r\n  mox.module('myApp').run();\r\n});\r\n```\r\n\r\n## Mox configuration methods\r\n\r\n### mox.setupResults()\r\n\r\nPass an object with a configuration for the spy functions of the already registered mocks.\r\nIf the value is a function, it will be set using Jasmine's `and.callFake()`, otherwise it uses `and.returnValue`\r\n\r\n```javascript\r\nmox.setupResults(function () {\r\n  return {\r\n    fooService: {\r\n      getBars: ['barData1', 'barData2'],\r\n      getTranslation: function (key) {\r\n        return key == 'fooTitle' ? 'mock title' : 'mock other string';\r\n      }\r\n    },\r\n    barFilter: 'mock filter result' // Object not allowed as return value\r\n  };\r\n});\r\n```\r\n\r\n### mox.mockTemplates()\r\n\r\nReplaces templates with a mock template: `<div>This is a mock for views/templateName.html</div>` or a custom template.\r\nThis is very useful when you want to mock an `ng-include` in your view spec. The mocked templates will be tested in a\r\nseparate view spec.\r\n\r\nNote that this method is not called in the chain that ends with `run()`. This is because `mockTemplates` needs the injector\r\nto already be initialized, which is done after calling `run()`.\r\n\r\n```javascript\r\nmox.mockTemplates(\r\n  'scripts/views/templatename.html',\r\n  { 'scripts/views/anotherTemplate.html': '<tr><td></td></tr>' }\r\n)\r\n```\r\n\r\nOr just one template:\r\n\r\n```javascript\r\nmox.mockTemplates('scripts/views/templateName.html');\r\n```\r\n\r\nOr:\r\n\r\n```javascript\r\nmox.mockTemplate({ 'scripts/views/anotherTemplate.html': '<tr><td></td></tr>' });\r\n```\r\n\r\n## Static methods/properties\r\n\r\n### mox.save()\r\n\r\nRegisters a mock and save it to the cache.\r\nThis method usually is used when defining a custom mock factory function or when manually creating a mock.\r\n\r\n```javascript\r\nmox.save($provide, 'FooService', fooServiceMock);\r\n```\r\n\r\nReturns the saved mock.\r\n\r\n### mox.get\r\n\r\nWhen a mock is registered, you can get the mock without injecting it.\r\n\r\n```javascript\r\nvar fooService = mox.get.FooService;\r\n```\r\n\r\n### mox.factories\r\n\r\nCall a mock factory function manually without chaining via `mox`.\r\nThe factory functions needs to be defined in moxConfig.\r\n\r\n```javascript\r\nmox.factories.FooServices($provide);\r\n```\r\n\r\n## Testing a $resource\r\n\r\nSetting up a resource test normally involves a lot of boilerplate code, like injecting $httpBackend, flushing, etc.\r\nWith Mox you can test a resource in 5 lines of code or less.\r\n\r\n```javascript\r\nrequestTest()\r\n  .whenMethod(FooResource.query, { bar: baz })\r\n  .expectGet('api/foo?bar=baz')\r\n  .andRespond([])\r\n  .run();\r\n```\r\n\r\nWhen you test a resource that returns an object, such as `get()`, `andRespond({})` is not necessary, since\r\n`requestTest()` responds with `{}` by default.\r\n\r\n## Utility functions\r\n\r\nFinally this framework contains a lot of utility functions:\r\n\r\n* Functions to prevent injecting common stuff like `$q`, `$controller`, `$compile` and `$rootScope` in the spec\r\n* Functions for quick promise and resource result mocking\r\n* Function to prevent writing duplicated selectors (addSelectors)\r\n\r\n### Generic shortcuts for specs\r\n\r\n* `createScope`: Creates a new $rootScope child. The optional passed argument is an object. Also sets the created scope on the current spec.\r\n* `createController(controllerName)`: Creates and initialized a controller.\r\n* `getMockData(fileName)`: Asynchronously loads the contents of a JSON file. The argument is a path without '.json'.\r\n\r\n### Compile shortcuts\r\n\r\n* `compileTemplate(path, $scope)`: Returns a compiled and linked template and digest the $scope.\r\n* `compileHtml(html, $scope)`: Returns compiled and linked HTML and digest the $scope. Useful for directives.\r\n\r\nThe compiled element is appended to the document body and is removed in between each spec.\r\nWhen you set `mox.testTemplatePath`, a the specified template is appended to the body first and the compiled element is\r\nappended to the element which can be found using the CSS selector in `mox.testTemplateAppendSelector`.\r\n\r\nWhen no scope is provided, it tries to use `this.$scope` which is set by `createScope()`.\r\nThe compiled element is set on the current spec.\r\n\r\n### Promise shortcuts\r\n\r\n* `defer`, `when`, `all`: shortcuts for `$q.defer`, `$q.when` and `$q.all`.\r\n* `unresolvedPromise`: returns `$q.defer().promise` without resolving it.\r\n* `promise(result, dontCopy)`: returns a promise that resolves to `result`. When `dontCopy` is false, the result object\r\nwill be copied before resolving.\r\n* `resourcePromise(result)`: returns a promise that resolves to `result`. The result is 'deep' copied using\r\n`angular.copy` so that functions on the result are not lost during copying.\r\n* `restangularPromise`: returns a promise using `$q.when`\r\n* `reject(message)`: returns a rejecting promise.\r\n* `resourceResult(result, mock)`: returns a resource result with a resolving promise - `{ $promise: resultPromise }`.\r\nIf you provide a mock, the functions of this mock are copied to the result as $-methods.\r\n* `rejectingResourceResult` and `nonResolvingResourceResult` return resource results with rejecting or empty promises.\r\n\r\n### addSelectors\r\n\r\nAdds helper functions to an element that simplify element selections.\r\nThe selection is only performed when the generated helper functions are called, so these work properly with changing DOM elements.\r\n\r\nExample template:\r\n\r\n```html\r\n<div>\r\n  <div id=\"header\"></div>\r\n  <div id=\"body\">\r\n    <div class=\"foo\">Foo</div>\r\n    <div data-test=\"bar\">\r\n      Bar <span class=\"hl\">something</span>\r\n    </div>\r\n    <div id=\"num-1-1\">Test 1</div>\r\n    <div id=\"num-2-1\">Test 2</div>\r\n    <div id=\"num-2-2\">Test 3</div>\r\n    <table>\r\n      <tbody>\r\n        <tr>\r\n          <td>Alice</td>\r\n          <td>54</td>\r\n          <td>Blue</td>\r\n        </tr>\r\n        <tr>\r\n          <td>Bob</td>\r\n          <td>54</td>\r\n          <td>Grey</td>\r\n        </tr>\r\n      </tbody>\r\n    </table>\r\n  </div>\r\n  <div id=\"footer\">\r\n    <h3>Footer <span>title</span></h3>\r\n    <div>Footer <span>content</span></div>\r\n  </div>\r\n</div>\r\n```\r\n\r\nTest initialisation:\r\n\r\n```html\r\nvar element = compileHtml(template);\r\naddSelectors(element, {\r\n  header: '[id=\"header\"]',               // shorthand string notation\r\n  body: {                                // full object notation\r\n    selector: '#body',                   // element selector\r\n    sub: {                               // descendant selectors\r\n      foo: '.foo',\r\n      bar: {\r\n        selector: '[data-test=\"bar\"]',\r\n        sub: {\r\n          highlight: '.hl'\r\n        }\r\n      },\r\n      num: '[id=\"num-{0}-{1}\"]'          // parameter placeholders can be used\r\n    }\r\n  },\r\n  resultsRows: {\r\n    repeater: 'tbody > tr',\r\n    children: ['name', 'age', 'eyeColor']\r\n  },\r\n  footer: {\r\n    selector: '#footer',\r\n    children: [                          // shorthand for child nodes, starting from first node\r\n      'heading',                         // shorthand string notation\r\n      {                                  // full object notation\r\n        name: 'content',\r\n        sub: {\r\n          innerSpan: 'span'\r\n        }\r\n      }\r\n    ],\r\n    sub: {                               // sub and children can be mixed\r\n      spans: 'span'                      // (as long as they don't overlap)\r\n    }\r\n  }\r\n});\r\n```\r\n\r\nTest code (Jasmine-style):\r\n\r\n```javascript\r\nexpect(element.header()).toExist();\r\n\r\nexpect(element.body()).toExist();\r\nexpect(element.body().foo()).toExist();\r\nexpect(element.body().bar()).toExist();\r\nexpect(element.body().bar().highlight()).toExist();\r\nexpect(element.body().num(1, 1)).toExist();\r\nexpect(element.body().num(2, 1)).toExist();\r\nexpect(element.body().num(2, 2)).toExist();\r\n\r\nexpect(element.resultRows()).toHaveLength(2);\r\nexpect(element.resultRows(0).name()).toExist();\r\nexpect(element.resultRows(0).age()).toExist();\r\nexpect(element.resultRows(0).eyeColor()).toExist();\r\n\r\nexpect(element.footer()).toExist();\r\nexpect(element.footer().heading()).toExist();\r\nexpect(element.footer().content()).toExist();\r\nexpect(element.footer().content().innerSpan()).toExist();\r\nexpect(element.footer().spans()).toHaveLength(2);\r\n```\r\n\r\n## Contributors\r\n\r\n* [@fvanwijk](https://github.com/fvanwijk)\r\n* [@AlbertBrand](https://github.com/AlbertBrand)\r\n* [@mikewoudenberg](https://github.com/mikewoudenberg)\r\n* [@fwielstra](https://github.com/fwielstra)\r\n* [@jbnicolai](https://github.com/jbnicolai)\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}